pipeline {
    agent any

    parameters {
        string(name: 'NEXUS_JAR_FILE_URL', description: 'URL Of The Existing Jar File In Nexus To be Deployed')
        string(name: 'DOCKER_IMAGE', description: 'Existing Docker Image To Be Deployed From Your DockerHub Registry. Eg: springboot-app-ci-cd:V004')
        string(name: 'CONTAINER_NAME', description: 'Your Preffered Name For Container To Be Created')
        string(name: 'NEXUS_JAR_FILE_URL', description: 'URL Of The Existing Jar File In Nexus To be Deployed')
        string(name: 'REMOTE_USER', defaultValue: 'ec2-user', description: 'Remote server username')
        string(name: 'MICROSERVICE_SERVER', defaultValue: 'microservice_server', description: 'The microservice server that Jenkins will SSH into Using Publish Over SSH.')
        string(name: 'MONOLITHIC_SERVER', defaultValue: 'monolithic_server', description: 'The monolithic server that Jenkins will SSH into Using Publish Over SSH.')
    }

    environment {
        REMOTE_USER = "${params.REMOTE_USER}"
        MICROSERVICE_SERVER = "${params.MICROSERVICE_SERVER}"
        MONOLITHIC_SERVER = "${params.MONOLITHIC_SERVER}"
    }

    stages {
        
        stage("Validate Parameters") {
            steps {
                script {
                    // Check if required parameters are provided
                    def requiredParameters = ['IMAGE_TAG', 'DOCKER_IMAGE', 'CONTAINER_NAME', 'REMOTE_USER', 'REGISTRY', 'REGISTRY_CREDENTIAL', 'GITHUB_CREDENTIAL', 'GITHUB_REPO_URL', 'GITHUB_BRANCH']
                    for (param in requiredParameters) {
                        if (!params.containsKey(param) || params[param].trim() == "") {
                            error("Parameter '$param' is missing or empty. Please provide a value.")
                        }
                    }
                }
            }
        }   

        stage('Deploy To Microservice Server') {
            steps {
                script {
                   def deployCommand = '''
    set -ex
    mkdir -p /home/${REMOTE_USER}/deployment
    echo 'version: "3.9"

services:
  blog-application:
    image: ${DOCKER_IMAGE}:V00${IMAGE_TAG}
    container_name: ${CONTAINER_NAME}
    ports:
      - "8081:8081"' > /home/${REMOTE_USER}/deployment/docker-compose.yml
    cd /home/${REMOTE_USER}/deployment/
    sudo docker rm -f ${CONTAINER_NAME}
    sudo /usr/local/bin/docker-compose down 
    echo 'Removed old container'
    sleep 3
    echo 'Starting a new container with the image ${DOCKER_IMAGE}:V00${IMAGE_TAG}'
    sudo /usr/local/bin/docker-compose up -d
'''


                    sshPublisher(publishers: [sshPublisherDesc(
                        configName: env.MICROSERVICE_SERVER,
                        transfers: [sshTransfer(
                            cleanRemote: false,
                            execCommand: deployCommand,
                            execTimeout: 120000,
                            flatten: false,
                            makeEmptyDirs: false,
                            noDefaultExcludes: false,
                            patternSeparator: '[, ]+',
                            remoteDirectory: '',
                            remoteDirectorySDF: false,
                            removePrefix: '',
                            sourceFiles: ''
                        )],
                        usePromotionTimestamp: false,
                        useWorkspaceInPromotion: false,
                        verbose: true
                    )])
                }
            }
        }

        stage('Deploy To Monolithic Server') {
            steps {
                script {
                   def Command = '''
                       set -ex
                       cd ~/blog-app/
                # Check if any process is listening on port 8081 and kill it
                PID=$(/usr/sbin/lsof -t -i:8081)
                if [ -n "$PID" ]; then
                    kill $PID || true
                    echo "Killed process $PID"
                else
                    echo "No process found listening on port 8081"
                fi

                # Run the new jar file
                java -jar blog-0.0.1-SNAPSHOT.jar > logfile 2>&1 &
                echo "Started new blog application"
                sleep 7
                cat logfile
            '''

            sshPublisher(publishers: [sshPublisherDesc(
                configName: env.MONOLITHIC_SERVER,
                transfers: [sshTransfer(
                    sourceFiles: 'target/blog-0.0.1-SNAPSHOT.jar',
                    removePrefix: 'target/',
                    makeEmptyDirs: false,
                    remoteDirectory: '/blog-app/',
                    execCommand: Command,
                    execTimeout: 120000
                )],
                usePromotionTimestamp: false,
                useWorkspaceInPromotion: false,
                verbose: true,
            )])
        }
    }
}


    }
}
